{{define "content"}}
<div x-data="scriptEditor()" x-init="init()">
    <div class="max-w-4xl mx-auto">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-3xl font-bold" x-text="scriptId ? 'Edit Script' : 'New Script'"></h1>
            <a href="/dashboard" class="text-gray-600 hover:text-gray-900">‚Üê Back to Dashboard</a>
        </div>

        <div class="bg-white p-8 rounded-lg shadow">
            <form @submit.prevent="saveScript" class="space-y-6">
                <div>
                    <label class="block text-sm font-medium mb-2">Script Name</label>
                    <input type="text" x-model="script.name" required 
                           :disabled="scriptId" 
                           class="w-full px-3 py-2 border rounded focus:ring-2 focus:ring-indigo-500"
                           placeholder="my-script">
                    <p class="text-xs text-gray-500 mt-1">Lowercase letters, numbers, and hyphens only</p>
                </div>

                <div>
                    <label class="block text-sm font-medium mb-2">Description</label>
                    <input type="text" x-model="script.description" 
                           class="w-full px-3 py-2 border rounded focus:ring-2 focus:ring-indigo-500"
                           placeholder="What does this script do?">
                </div>

                <div>
                    <label class="block text-sm font-medium mb-2">Visibility</label>
                    <select x-model="script.visibility" @change="visibilityChanged" class="w-full px-3 py-2 border rounded focus:ring-2 focus:ring-indigo-500">
                        <option value="public">Public - Listed and searchable</option>
                        <option x-show="tierFeatures.unlisted" value="unlisted">Unlisted</option>
                        <option x-show="tierFeatures.private" value="private">Private - Only you can access</option>
                    </select>
                    <p x-show="!tierFeatures.unlisted && !tierFeatures.private" class="text-xs text-gray-500 mt-1">
                        Upgrade to Pro for unlisted scripts or Ultimate for private scripts
                    </p>
                </div>

                <!-- Encryption options for private scripts -->
                <div x-show="script.visibility === 'private'" class="bg-yellow-50 border border-yellow-200 p-4 rounded">
                    <h3 class="font-bold mb-2">üîê Encryption Required</h3>
                    <p class="text-sm text-gray-700 mb-4">Private scripts must be encrypted since they're accessible without authentication.</p>
                    
                    <div>
                        <label class="block text-sm font-medium mb-2">Select Key for Encryption</label>
                        <select x-model="script.keypair_id" :required="script.visibility === 'private'" class="w-full px-3 py-2 border rounded focus:ring-2 focus:ring-indigo-500">
                            <option value="">-- Select a key --</option>
                            <template x-for="key in keys" :key="key.id">
                                <option :value="key.id" x-text="key.name"></option>
                            </template>
                        </select>
                        <p class="text-xs text-gray-600 mt-1">
                            <a href="/keys" class="text-indigo-600 hover:text-indigo-700">Manage keys</a> or 
                            <a href="/keys" class="text-indigo-600 hover:text-indigo-700">create a new key</a>
                        </p>
                    </div>
                </div>

                <!-- Private key input for decrypting existing encrypted scripts -->
                <div x-show="scriptId && needsDecryption" class="bg-red-50 border border-red-200 p-4 rounded">
                    <h3 class="font-bold mb-2">üîë Private Key Required</h3>
                    <p class="text-sm text-gray-700 mb-2">This script is encrypted. Provide your private key to decrypt and edit.</p>
                    <textarea x-model="privateKey" 
                              class="w-full px-3 py-2 border rounded font-mono text-xs"
                              rows="8"
                              placeholder="-----BEGIN RSA PRIVATE KEY-----&#10;...&#10;-----END RSA PRIVATE KEY-----"></textarea>
                    <button type="button" @click="decryptScript" class="mt-2 bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700">
                        Decrypt Script
                    </button>
                </div>

                <div x-show="scriptId">
                    <label class="block text-sm font-medium mb-2">Tag (optional)</label>
                    <select x-model="script.tag" class="w-full px-3 py-2 border rounded focus:ring-2 focus:ring-indigo-500">
                        <option value="">No tag</option>
                        <option value="dev">@dev</option>
                        <option value="beta">@beta</option>
                    </select>
                    <p class="text-xs text-gray-500 mt-1">Tag this version for easy access</p>
                </div>

                <div>
                    <label class="block text-sm font-medium mb-2">Script Content</label>
                    <textarea id="code-editor" x-model="script.content" required
                              :disabled="needsDecryption"
                              class="w-full px-3 py-2 border rounded font-mono text-sm focus:ring-2 focus:ring-indigo-500"
                              rows="20"
                              placeholder="#!/bin/bash&#10;echo 'Hello World'"></textarea>
                    <p x-show="needsDecryption" class="text-xs text-red-600 mt-1">Decrypt the script first to edit</p>
                </div>

                <div x-show="error" class="bg-red-50 text-red-600 p-3 rounded" x-text="error"></div>
                <div x-show="success" class="bg-green-50 text-green-600 p-3 rounded">Script saved successfully!</div>

                <div class="flex space-x-4">
                    <button type="submit" :disabled="needsDecryption" 
                            :class="needsDecryption ? 'bg-gray-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-700'"
                            class="text-white px-6 py-2 rounded">
                        <span x-text="scriptId ? 'Update Script' : 'Create Script'"></span>
                    </button>
                    <a href="/dashboard" class="bg-gray-300 px-6 py-2 rounded hover:bg-gray-400">Cancel</a>
                </div>
            </form>
        </div>
    </div>
</div>

<script>
function scriptEditor() {
    return {
        scriptId: null,
        script: {
            name: '',
            description: '',
            visibility: 'public',
            content: '',
            tag: '',
            keypair_id: null
        },
        keys: [],
        tierFeatures: { public: true, unlisted: false, private: false },
        useEncryption: false,
        needsDecryption: false,
        privateKey: '',
        error: '',
        success: false,
        editor: null,
        
        async init() {
            if (!getToken()) {
                window.location.href = '/login';
                return;
            }
            
            await this.loadTierFeatures();
            this.setDefaultVisibility();
                return;
            }
            
            const params = new URLSearchParams(window.location.search);
            this.scriptId = params.get('id');
            
            this.loadKeys();
            
            if (this.scriptId) {
                this.loadScript();
            } else {
                // For new scripts, init editor after DOM is ready
                setTimeout(() => this.initEditor(), 100);
            }
        },
        
        loadKeys() {
            fetch('/api/keys', {
                headers: { 'Authorization': 'Bearer ' + getToken() }
            })
            .then(res => res.json())
            .then(data => this.keys = data || []);
        },
        
        async loadTierFeatures() {
            try {
                const response = await fetch('/api/account/tier', {
                    headers: { 'Authorization': 'Bearer ' + getToken() }
                });
                if (response.ok) {
                    const tier = await response.json();
                    this.tierFeatures = tier.features || { public: true, unlisted: false, private: false };
                }
            } catch (e) {
                console.error('Failed to load tier:', e);
            }
        },
        
        setDefaultVisibility() {
            // Set default based on tier
            if (this.tierFeatures.private) {
                this.script.visibility = 'private';
            } else if (this.tierFeatures.unlisted) {
                this.script.visibility = 'unlisted';
            } else {
                this.script.visibility = 'public';
            }
        },
        
        initEditor() {
            const textarea = document.getElementById('code-editor');
            if (!textarea) return;
            if (this.editor) return;
            
            try {
                this.editor = CodeMirror.fromTextArea(textarea, {
                    mode: 'shell',
                    lineNumbers: true,
                    theme: 'default',
                    lineWrapping: true,
                    value: this.script.content || ''
                });
                
                this.editor.on('change', (cm) => {
                    this.script.content = cm.getValue();
                });
            } catch (e) {
                console.error('CodeMirror init failed:', e);
            }
        },
        
        loadScript() {
            fetch('/api/scripts/' + this.scriptId, {
                headers: { 'Authorization': 'Bearer ' + getToken() }
            })
            .then(res => {
                if (!res.ok) throw new Error('Failed to load script');
                return res.json();
            })
            .then(data => {
                this.script = {
                    name: data.name,
                    description: data.description,
                    visibility: data.visibility,
                    content: '',
                    tag: '',
                    keypair_id: data.keypair_id || null
                };
                
                // Check if script is encrypted
                if (data.encrypted) {
                    this.needsDecryption = true;
                    this.useEncryption = true;
                    return Promise.resolve();
                }
                
                // Load content for non-encrypted scripts
                const user = JSON.parse(localStorage.getItem('user'));
                return fetch(`/${user.username}/${data.name}`);
            })
            .then(res => {
                if (res && !this.needsDecryption) {
                    return res.text();
                }
                return null;
            })
            .then(content => {
                if (content && !this.needsDecryption) {
                    this.script.content = content;
                }
                
                // Always init editor after load completes
                setTimeout(() => this.initEditor(), 200);
            })
            .catch(err => {
                console.error('Error loading script:', err);
                // Still init editor even if load fails
                setTimeout(() => this.initEditor(), 200);
            });
        },
        
        visibilityChanged() {
            if (this.script.visibility === 'private') {
                // Private scripts must be encrypted
                this.useEncryption = true;
            } else {
                this.useEncryption = false;
                this.script.keypair_id = null;
            }
        },
        
        encryptionToggled() {
            // Cannot disable encryption for private scripts
            if (this.script.visibility === 'private') {
                this.useEncryption = true;
            }
            if (!this.useEncryption) {
                this.script.keypair_id = null;
            }
        },
        
        decryptScript() {
            this.error = '';
            
            if (!this.privateKey) {
                this.error = 'Please provide your private key';
                return;
            }
            
            // Fetch encrypted content and wrapped key
            fetch(`/api/scripts/${this.scriptId}/encrypted`, {
                headers: { 'Authorization': 'Bearer ' + getToken() }
            })
            .then(res => res.json())
            .then(async (data) => {
                try {
                    console.log('Wrapped key type:', typeof data.wrapped_key);
                    console.log('Wrapped key length:', data.wrapped_key ? data.wrapped_key.length : 0);
                    
                    // Import private key
                    const cryptoKey = await ShebangCrypto.importPrivateKey(this.privateKey);
                    console.log('Private key imported');
                    
                    // Convert base64 string to bytes (JSON encodes []byte as base64)
                    let wrappedKeyBytes;
                    if (typeof data.wrapped_key === 'string') {
                        wrappedKeyBytes = ShebangCrypto.base64ToArrayBuffer(data.wrapped_key);
                        wrappedKeyBytes = new Uint8Array(wrappedKeyBytes);
                    } else if (Array.isArray(data.wrapped_key)) {
                        wrappedKeyBytes = new Uint8Array(data.wrapped_key);
                    } else {
                        wrappedKeyBytes = data.wrapped_key;
                    }
                    
                    console.log('Wrapped key bytes:', wrappedKeyBytes.length);
                    
                    // Convert encrypted content
                    let encryptedBytes;
                    if (typeof data.encrypted_content === 'string') {
                        encryptedBytes = ShebangCrypto.base64ToArrayBuffer(data.encrypted_content);
                        encryptedBytes = new Uint8Array(encryptedBytes);
                    } else if (Array.isArray(data.encrypted_content)) {
                        encryptedBytes = new Uint8Array(data.encrypted_content);
                    } else {
                        encryptedBytes = data.encrypted_content;
                    }
                    
                    // Unwrap (decrypt) the symmetric key
                    const symmetricKey = await ShebangCrypto.unwrapKey(wrappedKeyBytes, cryptoKey);
                    console.log('Symmetric key unwrapped:', symmetricKey.length, 'bytes');
                    
                    // Decrypt the content
                    const decryptedContent = await ShebangCrypto.decryptContent(
                        encryptedBytes,
                        symmetricKey
                    );
                    console.log('Content decrypted');
                    
                    // Set the decrypted content
                    this.script.content = decryptedContent;
                    
                    // Destroy and recreate editor to fix state
                    if (this.editor) {
                        this.editor.toTextArea();
                        this.editor = null;
                    }
                    
                    // Reinitialize editor with decrypted content
                    setTimeout(() => {
                        this.initEditor();
                    }, 100);
                    
                    // Clear the decryption flag
                    this.needsDecryption = false;
                    this.privateKey = ''; // Clear private key from memory
                    
                } catch (err) {
                    console.error('Decryption error:', err);
                    this.error = 'Decryption failed: ' + err.message;
                }
            })
            .catch(err => {
                console.error('Fetch error:', err);
                this.error = 'Failed to fetch encrypted content: ' + err.message;
            });
        },
        
        saveScript() {
            this.error = '';
            this.success = false;
            
            // Private scripts must have encryption key selected
            if (this.script.visibility === 'private' && !this.script.keypair_id) {
                this.error = 'Private scripts require encryption. Please select a key.';
                return;
            }
            
            const url = this.scriptId ? `/api/scripts/${this.scriptId}` : '/api/scripts';
            const method = this.scriptId ? 'PUT' : 'POST';
            
            const payload = {
                name: this.script.name,
                description: this.script.description,
                visibility: this.script.visibility,
                content: this.script.content,
                tag: this.script.tag || undefined,
                keypair_id: this.script.visibility === 'private' ? this.script.keypair_id : null
            };
            
            fetch(url, {
                method: method,
                headers: {
                    'Authorization': 'Bearer ' + getToken(),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
            .then(res => {
                if (!res.ok) throw new Error('Failed to save script');
                return res.text().then(text => text ? JSON.parse(text) : {});
            })
            .then(() => {
                this.success = true;
                setTimeout(() => {
                    window.location.href = '/dashboard';
                }, 1500);
            })
            .catch(err => {
                this.error = err.message;
            });
        }
    }
}
</script>
{{end}}

